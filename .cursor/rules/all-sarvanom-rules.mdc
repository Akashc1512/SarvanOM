---
alwaysApply: true
---
0. Always try to reuse any files before deleting or deprecating it.

1. Code Organization & Structure
    All backend services must follow microservices structure, even if in a monorepo.

    Each service (retrieval, synthesis, fact-check, auth, search) should have:

    main.py entrypoint

    routers/ for API endpoints

    services/ for core logic

    models/ for data models

    utils/ for helpers

    No shared code duplication. Use shared/ module for reusable components (e.g., logging, DB clients).

2. Frontend Rules
    Frontend must consume every backend service via API calls. No direct database reads.

    UI must be designed like Anthropic + Perplexity hybrid UX:

    Main answer at top.

    Sources, images, videos in side panels or tabs.

    Use Next.js 14 App Router only.

    Tailwind CSS for all styling. No CSS-in-JS.

    Use React Suspense for Data Fetching wherever applicable.

    Avoid global state where unnecessary — use React Context API sparingly.

3. File/Folder Hygiene
    No file/folder outside these allowed:

    /frontend

    /services/[service_name]

    /shared

    /docker

    /scripts

    .env, .env.docker, .gitignore, README.md

    .venv/ must be in root and used for all Python deps.

    Remove .next/, .pytest_cache/, node_modules/ from Git.

    All test artifacts like coverage.xml, .coverage must be Git-ignored.

4. Environment & Dependencies
    No global Python installs used. All services run within .venv.

    Only one requirements.txt for backend (use pip-tools if needed).

    Frontend has single package.json (no multi-workspace setups).

    Use .env.docker for all environment configurations (use dotenv in code to load).

    Ollama models, Meilisearch, ArangoDB, Postgres, Qdrant must run in Docker Compose for local dev.

5. LLM & Retrieval Rules
    All Retrieval must be Hybrid (Vector DB + Keyword DB + Web Search).

    For web search, prioritize free APIs (Brave, SerpAPI free tier).

    LLM Calls:

    Use Ollama/local models first.

    Use API-based LLMs (OpenAI/Claude) only if query complexity demands.

    Always check environment flags: USE_DYNAMIC_SELECTION, PRIORITIZE_FREE_MODELS.

6. Coding Standards
    Python must follow PEP8 + Black formatting.

    Type hints are mandatory for all functions.

    All API endpoints must be documented using FastAPI’s OpenAPI schema.

    For React, follow strict ESLint + Prettier rules.

    Avoid React any type in TypeScript, unless absolutely necessary (always narrow types).

7. Testing Rules
    Every service must have at least:

    Unit tests for core logic.

    Integration tests for API endpoints.

    Use pytest with pytest-asyncio for async code.

    Frontend must have basic E2E tests using Playwright for critical flows (query submit, result view).

8. Performance & Monitoring
    All API requests must be logged with timestamp, service, and latency.

    Use Prometheus metrics endpoint for every service.

    Logs must be structured JSON logs (no print/debug statements in production).

    Frontend should lazy-load heavy components (e.g., Knowledge Graph Visualizer).

9. Zero Budget First Policy
    Every implementation must prioritize open-source / free-tier APIs.

    Paid services (OpenAI, Claude) must have fallback to local LLMs via Ollama.

    Web Search must prefer Brave Search API free tier or SerpAPI free tier.

    Redis is optional — PostgreSQL JSONB is primary cache.

10. CI/CD Readiness (Even for Local Dev)
    All code must pass:

    make lint

    make test

    docker-compose up --build without errors.

    Each PR must be clean — no WIP commits pushed to main.

---
alwaysApply: true
---